# -*- coding: utf-8 -*-
"""App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xEUHYF5gcqokWcgVevScFXorkPdDwvhY
"""

import os
import io
import joblib
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import gradio as gr

sns.set(style="whitegrid")
plt.rcParams['figure.figsize'] = (6,4)

MODEL_PATH = "rf_model.joblib"

def load_csv(file_obj):
    """Load uploaded csv (file_obj is a tempfile-like object from Gradio)."""
    if file_obj is None:
        return None, "No file uploaded"
    try:
        # Gradio gives a tempfile path or file-like, ensure reading robustly
        df = pd.read_csv(file_obj.name) if hasattr(file_obj, "name") else pd.read_csv(io.StringIO(file_obj.read().decode('utf-8')))
        return df, f"Loaded CSV with shape {df.shape}"
    except Exception as e:
        return None, f"Error loading CSV: {e}"

def get_columns(df):
    if df is None:
        return []
    return list(df.columns)

def train_model(df, target_col, feature_cols, test_size, n_estimators, random_state):
    """Train RandomForest on chosen columns. Return metrics, confusion matrix plot, and saved model path."""
    if df is None:
        return "No dataset loaded.", None, None, None
    if target_col not in df.columns:
        return "Target column invalid.", None, None, None
    if not feature_cols:
        return "Please select one or more feature columns.", None, None, None

    # Drop rows with NA in selected columns
    sub = df[feature_cols + [target_col]].dropna()
    X = sub[feature_cols]
    y = sub[target_col]

    # If y is non-numeric, encode using pandas factorize
    if y.dtype == object or y.dtype.name == 'category':
        y, uniques = pd.factorize(y)
        label_map = {i: v for i, v in enumerate(uniques)}
    else:
        label_map = None

    try:
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=float(test_size), random_state=int(random_state), stratify=y if len(np.unique(y))>1 else None)
    except Exception as e:
        # fallback without stratify
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=float(test_size), random_state=int(random_state))

    model = RandomForestClassifier(n_estimators=int(n_estimators), random_state=int(random_state))
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)

    acc = accuracy_score(y_test, y_pred)
    report = classification_report(y_test, y_pred, zero_division=0)
    cm = confusion_matrix(y_test, y_pred)

    # Plot confusion matrix
    fig, ax = plt.subplots()
    sns.heatmap(cm, annot=True, fmt="d", ax=ax)
    ax.set_xlabel("Predicted")
    ax.set_ylabel("True")
    ax.set_title(f"Confusion Matrix (acc={acc:.3f})")
    plt.tight_layout()
    # save plot to bytes
    buf = io.BytesIO()
    fig.savefig(buf, format="png")
    plt.close(fig)
    buf.seek(0)

    # Save model + metadata
    metadata = {"feature_cols": feature_cols, "target_col": target_col, "label_map": label_map}
    joblib.dump({"model": model, "meta": metadata}, MODEL_PATH)

    summary = f"Trained RandomForest (n_estimators={n_estimators}). Accuracy on test set: {acc:.4f}\n\nClassification Report:\n{report}"
    return summary, buf, MODEL_PATH, metadata

def predict_from_model(model_path, csv_row_content):
    """csv_row_content: string of comma-separated values matching feature order saved in model meta."""
    if not os.path.exists(model_path):
        return "No trained model found. Train first.", None
    data = joblib.load(model_path)
    model = data["model"]
    meta = data["meta"]
    feature_cols = meta["feature_cols"]
    label_map = meta.get("label_map")

    # Try parse input: accept either CSV string with header or single line of values
    try:
        # If user uploads a small CSV text with header, try reading it
        df_try = pd.read_csv(io.StringIO(csv_row_content))
        # If multiple rows, take first
        input_df = df_try.iloc[[0]][feature_cols]
    except Exception:
        # parse as a single comma-separated line of numbers/strings
        parts = [p.strip() for p in csv_row_content.strip().split(',')]
        if len(parts) != len(feature_cols):
            return f"Input has {len(parts)} values but model expects {len(feature_cols)} features: {feature_cols}", None
        input_df = pd.DataFrame([parts], columns=feature_cols)

        # Attempt to convert numeric columns
        for c in input_df.columns:
            try:
                input_df[c] = pd.to_numeric(input_df[c])
            except:
                pass

    preds = model.predict(input_df)
    pred_label = preds[0]
    if label_map:
        pred_readable = label_map.get(pred_label, str(pred_label))
    else:
        pred_readable = str(pred_label)

    return f"Prediction: {pred_readable}", pred_readable

# === Gradio interface ===
with gr.Blocks() as demo:
    gr.Markdown("# Simple ML Playground — RandomForest\nUpload CSV → pilih target & fitur → Train → lihat metrik → Predict")
    with gr.Row():
        csv_in = gr.File(label="Upload CSV dataset (required)", file_count="single", file_types=[".csv"])
        load_btn = gr.Button("Load CSV")
    df_out = gr.Dataframe(interactive=False, label="Dataset preview (first 100 rows)")
    msg_out = gr.Textbox(label="Status / Messages", interactive=False)

    with gr.Row():
        target_dropdown = gr.Dropdown(choices=[], label="Target column (y)", interactive=True)
        features_checkbox = gr.CheckboxGroup(choices=[], label="Feature columns (X)")
    with gr.Row():
        test_size_slider = gr.Slider(minimum=0.05, maximum=0.5, value=0.2, step=0.05, label="Test size")
        n_estimators_slider = gr.Slider(minimum=10, maximum=500, step=10, value=100, label="n_estimators (RandomForest)")
        rand_state = gr.Number(value=42, label="Random state")
    train_btn = gr.Button("Train model")
    metrics_out = gr.Textbox(label="Training output (accuracy + report)", interactive=False)
    cm_image = gr.Image(label="Confusion matrix")

    gr.Markdown("### Predict (single row)\nMasukkan satu baris CSV tanpa header (nilai dipisah koma) atau upload CSV satu baris.")
    predict_text = gr.Textbox(label="Single-row CSV text (comma-separated)", lines=2, placeholder="e.g. 0.25, 200, 1")
    predict_btn = gr.Button("Predict")
    predict_out = gr.Textbox(label="Prediction result", interactive=False)

    # Callbacks
    def on_load(file_obj):
        df, msg = load_csv(file_obj)
        if df is None:
            return gr.update(value=None), msg, [], []
        # show first 100 rows
        preview = df.head(100)
        cols = list(df.columns)
        return preview, f"{msg}", gr.Dropdown.update(choices=cols, value=cols[0]), gr.CheckboxGroup.update(choices=cols, value=[c for c in cols if pd.api.types.is_numeric_dtype(df[c])][:3])

    load_btn.click(on_load, inputs=[csv_in], outputs=[df_out, msg_out, target_dropdown, features_checkbox])

    def on_train(df_obj, target_col, feature_cols, test_size, n_estimators, rs):
        # df_obj from gr.Dataframe is a pandas DataFrame already
        if isinstance(df_obj, dict) or df_obj is None:
            return "No data present to train.", None, None, None
        # if gr.Dataframe passes as pd.DataFrame, keep; else try to coerce
        if not isinstance(df_obj, pd.DataFrame):
            try:
                df_local = pd.DataFrame(df_obj)
            except:
                return "Invalid dataframe object.", None, None, None
        else:
            df_local = df_obj
        summary, buf, model_path, meta = train_model(df_local, target_col, feature_cols, test_size, n_estimators, rs)
        if buf is not None:
            # return image file-like
            return summary, buf
        else:
            return summary, None

    train_btn.click(on_train, inputs=[df_out, target_dropdown, features_checkbox, test_size_slider, n_estimators_slider, rand_state], outputs=[metrics_out, cm_image])

    predict_btn.click(lambda txt: predict_from_model(MODEL_PATH, txt), inputs=[predict_text], outputs=[predict_out])

    gr.Markdown("**Notes:** Model saved to `rf_model.joblib` in workspace. For production, save trained model separately and load at start.")

if __name__ == "__main__":
    demo.launch(server_name="0.0.0.0", server_port=int(os.environ.get("PORT", 7860)))